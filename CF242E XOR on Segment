#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <numeric>
#define R(a,b,c) for(register int a = (b); a <= (c); ++a)
#define nR(a,b,c) for(register int a = (b); a >= (c); --a)
#define Swap(a,b) ((a) ^= (b) ^= (a) ^= (b))
#define MP make_pair
#ifdef QWQ
#define D_e_Line printf("\n------\n")
#define D_e(x) cerr << (#x) << " " << x << endl
#define C_e(x) cout << (#x) << " " << x << endl
#define FileOpen() freopen("in.txt", "r", stdin)
#define FileSave() freopen("out.txt", "w", stdout)
#define Pause() system("pause")
#include <cassert>
#define PASS fprintf(stderr, "Passing [%s] in LINE %d\n",__FUNCTION__,__LINE__)
#else
#define D_e_Line
#define D_e(x)
#define C_e(x)
#define FileOpen()
#define FileSave()
#define Pause()
#define PASS
#endif
using namespace std;
struct FastIO {
    template<typename ATP> inline FastIO& operator >> (ATP &x) {
        x = 0; int sign = 1; char c;
        for(c = getchar(); c < '0' || c > '9'; c = getchar()) if(c == '-') sign = -1;
        while(c >= '0' && c <= '9') x = x * 10 + (c ^ '0'), c = getchar();
        if(sign == -1) x = -x;
        return *this;
    }
    template<typename ATP> inline FastIO& operator << (ATP x) {
    	char s[66]; int digit = 0;
    	if(x == 0) putchar('0');
    	else if(x < 0) x = -x, putchar('-');
    	while(x) s[++digit] = x % 10 ^ '0', x /= 10;
    	for(int i = digit; i; --i) putchar(s[i]);
    	return *this;
	}
} io;
using namespace std;

const int N = 1e5 + 3;

#define int long long
int val[N], digit[N];

namespace segment_tree {

#define ls rt << 1
#define rs rt << 1 | 1
#define lson rt << 1, l, mid
#define rson rt << 1 | 1, mid + 1, r
struct segment_tree {
	int sum; bool tag;
} t[21][N << 2];

void push_up(int rt, int pos) {
	t[pos][rt].sum = t[pos][ls].sum + t[pos][rs].sum;
}

void build_tree(int rt, int l, int r, int pos) {
	if(l == r) {
		if(val[l] & digit[pos]) t[pos][rt].sum = 1;
		return;
	}
	int mid = l + r >> 1;
	build_tree(lson, pos), build_tree(rson, pos);
	push_up(rt, pos);
}

void push_down(int rt, int l, int r, int pos) {
	if(!t[pos][rt].tag) return;
	int mid = l + r >> 1;
	t[pos][ls].sum = mid - l + 1 - t[pos][ls].sum;
	t[pos][rs].sum = r - mid - t[pos][rs].sum;
	t[pos][ls].tag ^= 1;
	t[pos][rs].tag ^= 1;
	t[pos][rt].tag = false;
}

void update(int rt, int l, int r, int L, int R, int pos) {
	if(L <= l && r <= R) {
		t[pos][rt].sum = r - l + 1 - t[pos][rt].sum;
		t[pos][rt].tag ^= 1;
		return;
	}
	push_down(rt, l, r, pos);
	int mid = l + r >> 1;
	if(mid >= L) update(lson, L, R, pos);
	if(R > mid) update(rson, L, R, pos);
	push_up(rt, pos);
}

int query(int rt, int l, int r, int L, int R, int pos) {
	if(L <= l && r <= R) return t[pos][rt].sum;
	push_down(rt, l, r, pos);
	int mid = l + r >> 1, sum = 0;
	if(mid >= L) sum += query(lson, L, R, pos);
	if(R > mid) sum += query(rson, L, R, pos);
	return sum;
}

}
using namespace segment_tree;

#undef int
int main() {
#define int long long
FileOpen();
	int n, tasks;
	io >> n;
	
	for(int i = 1; i <= n; ++i) io >> val[i];
	
	digit[0] = 1;
	for(int i = 1; i <= 20; ++i) digit[i] = digit[i - 1] << 1;
	
	for(int i = 0; i <= 20; ++i) build_tree(1, 1, n, i);
	
	
	io >> tasks;
	while(tasks--) {
		int opt, l, r;
		io >> opt >> l >> r;
		if(opt == 1) {
			int sum = 0;
			for(int i = 0; i <= 20; ++i) {
				sum += digit[i] * query(1, 1, n, l, r, i);
			}
			printf("%lld\n", sum);
		}
		else {
			int x;
			io >> x;
			for(int i = 0; i <= 20; ++i) {
				if(x & digit[i]) {
					update(1, 1, n, l, r, i);
				}
			}
		}
	}
	
	return 0;
}
